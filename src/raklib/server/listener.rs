use crate::raklib::protocol::EncapsulatedPacket;
use crate::raklib::error::DisconnectReason;
use std::net::SocketAddr;

/// Trait for determining if a server accepts a client's RakNet protocol version.
pub trait ProtocolAcceptor: Send + Sync {
    fn accepts(&self, protocol_version: u8) -> bool;
    fn primary_version(&self) -> u8; // The version server advertises/prefers
}

/// Simple implementation accepting only one specific protocol version.
#[derive(Debug, Copy, Clone)]
pub struct SimpleProtocolAcceptor {
    protocol_version: u8,
}

impl SimpleProtocolAcceptor {
    pub fn new(protocol_version: u8) -> Self { Self { protocol_version } }
}

impl ProtocolAcceptor for SimpleProtocolAcceptor {
    fn accepts(&self, protocol_version: u8) -> bool {
        self.protocol_version == protocol_version
    }
    fn primary_version(&self) -> u8 {
        self.protocol_version
    }
}

/// Trait for handling events generated by the RakNet server.
/// Implement this trait to react to client connects, disconnects, packets, etc.
// Note: Consider using async traits if event handling needs to be async.
pub trait ServerEventListener: Send + Sync {
    // Use unique session ID (e.g., u64 counter) instead of SocketAddr as primary key
    fn on_client_connect(&self, session_id: u64, address: SocketAddr, client_id: u64);
    fn on_client_disconnect(&self, session_id: u64, reason: DisconnectReason);
    /// Called when a user data packet (ID >= 0x86) is received.
    fn on_packet_receive(&self, session_id: u64, packet: Vec<u8>); // Use Vec<u8> for payload
    /// Called when a raw, unhandled packet is received (if filters match or default).
    fn on_raw_packet_receive(&self, address: SocketAddr, payload: Vec<u8>);
    /// Called when a packet sent with an identifier_ack is ACKed.
    fn on_packet_ack(&self, session_id: u64, identifier_ack: u32);
    /// Called periodically with bandwidth usage stats (bytes since last update).
    fn on_bandwidth_stats_update(&self, bytes_sent_diff: u64, bytes_received_diff: u64);
    /// Called when a new ping measurement is available.
    fn on_ping_measure(&self, session_id: u64, ping_ms: u32);
}

/// Trait for an external event source that can interact with the server.
/// Allows processing commands or other events within the server tick loop.
// Maybe rename? 'CommandSource' or 'ExternalEventProcessor'?
pub trait ServerEventSource: Send + Sync {
    /// Process external events. Return false if no more events are pending.
    fn process(&mut self, server: &mut dyn ServerInterface) -> bool; // Pass mutable trait object
}


/// Trait defining the interface for interacting with the server, often used by sessions or event sources.
// Needs refinement based on actual interactions needed.
pub trait ServerInterface {
    // Use session_id (u64) as the primary identifier
    fn send_encapsulated(&mut self, session_id: u64, packet: EncapsulatedPacket, immediate: bool);
    fn send_raw(&mut self, address: SocketAddr, payload: Vec<u8>);
    fn close_session(&mut self, session_id: u64, reason: DisconnectReason);
    fn set_name(&mut self, name: String);
    fn set_port_check(&mut self, enabled: bool);
    fn set_packets_per_tick_limit(&mut self, limit: u32);
    fn block_address(&mut self, address: std::net::IpAddr, timeout_secs: u64);
    fn unblock_address(&mut self, address: std::net::IpAddr);
    // Removed addRawPacketFilter, handle filtering differently in Rust (e.g., config)
}